/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v12.0.7.0 (NJsonSchema v9.13.4.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch, debounceTime, distinctUntilChanged, filter, switchMap, map, mergeMap, catchError } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf, Subject, merge, throwError, of } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase, HttpEvent, HttpRequest } from '@angular/common/http';
import { ChangeUiThemeInput, AuthenticateModel, AuthenticateResultModel, ExternalLoginProviderInfoModel, ExternalAuthenticateModel, ExternalAuthenticateResultModel, SwaggerException, GetCurrentLoginInformationsOutput, ContactUsDto, ForgotPasswordDto, ResendVerificationEmailInputDto, ForgotPasswordInputDto, ContactConfirmInputDto, ConfirmEmailOuputDto } from './dto/auth-models';
import { ListResultDtoOfDropdownDto } from './dto/dropdown-dto';
import { AppConfigService } from './AppConfigService';
import { RegisterInput, RegisterOutput } from './dto/register-models';
import { TenantDto, IsTenantAvailableOutput, IsTenantAvailableInput } from './dto/company/tenant-dto';
import { UserProfileInputDto } from './dto/user/user-profile-input.dto';
import { UserProfileOutputDto } from './dto/user/user-profile-output.dto';
import { JobAdDto } from './dto/company/job-ad-dto';
import { UserTestResultDto } from './dto/user/user-test-result.dto';
import { UserPreferenceDto } from './dto/user-preference-dto';
import { UserInfoDto } from './dto/user-info-dto';
import { ConfirmInvitationDto } from './dto/company/confirm-invitation-dto';
import { ListResultDtoOfUserEducationDto, UserEducationDto } from './dto/user/user-education-dto';
import { ListResultDtoOfUserImageDto } from './dto/user/user-image.dto';
import { ListResultDtoOfUserCertificationDto, UserCertificationDto } from './dto/user/user-certification-dto';
import { UserExperienceDto, ListResultDtoOfUserExperienceDto } from './dto/user/user-experience-dto';
import { CompanyImageDto, ListResultDtoOfCompanyImageDto } from './dto/company/company-image-dto';
import { ListSkillCategoryDto } from './dto/skill-category-dto';
import { ListUserSkillDto, UserSkillDto } from './dto/user-skill-dto';
import { CompanyOverviewDto } from './dto/company/company-overview-dto';
import { NgbTypeahead } from '@ng-bootstrap/ng-bootstrap';


@Injectable()
export class ConfigurationServiceProxy {
  private http: HttpClient;
  public baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient,
    private appConfigService: AppConfigService
  ) {
    this.http = http;
    this.baseUrl = appConfigService.apiBaseUrl;
  }

  /**
   * @param input (optional)
   * @return Success
   */
  changeUiTheme(input: ChangeUiThemeInput | null | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/services/app/Configuration/ChangeUiTheme";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(input);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processChangeUiTheme(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processChangeUiTheme(<any>response_);
        } catch (e) {
          return <Observable<void>><any>_observableThrow(e);
        }
      } else
        return <Observable<void>><any>_observableThrow(response_);
    }));
  }

  protected processChangeUiTheme(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return _observableOf<void>(<any>null);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(<any>null);
  }
}
@Injectable()
export class DropdownProxyService {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient,
    private appConfigService: AppConfigService
  ) {
    this.http = http;
    this.baseUrl = appConfigService.apiBaseUrl;
  }

  smartSearch(text$: Observable<any>, element: NgbTypeahead, click: Subject<string>, focus: Subject<string>, url: string) {
    const debouncedText$ = text$.pipe(debounceTime(200), distinctUntilChanged());
    const clicksWithClosedPopup$ = click.pipe(filter(() => !element.isPopupOpen()));
    const inputFocus$ = focus;
    return merge(debouncedText$, inputFocus$, clicksWithClosedPopup$)
        .pipe(debounceTime(200), distinctUntilChanged(), switchMap(term =>
            // term.length < 2 ? [] :
            this.getDropdownByUrl(url)
                .pipe(map(s => s.items))));
}

  getDropdownByUrl(input: string): Observable<ListResultDtoOfDropdownDto> {
    const content_ = JSON.stringify(input);
    let url_ = this.baseUrl + input;
    url_ = url_.replace(/[?&]$/, '');

    const options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      })
    };

    return this.http.request('get', url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processGetDropdownByUrl(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetDropdownByUrl(<any>response_);
        } catch (e) {
          return <Observable<ListResultDtoOfDropdownDto>><any>_observableThrow(e);
        }
      } else {
        return <Observable<ListResultDtoOfDropdownDto>><any>_observableThrow(response_);
      }
    }));
  }

  private processGetDropdownByUrl(response: HttpResponseBase): Observable<ListResultDtoOfDropdownDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    const _headers: any = {};
    if (response.headers) {
      for (const key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        const resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? ListResultDtoOfDropdownDto.fromJS(resultData200) : new ListResultDtoOfDropdownDto();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      }));
    }
    return _observableOf<ListResultDtoOfDropdownDto>(<any>null);
  }
}

@Injectable()
export class TokenAuthServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient,
    private appConfigService: AppConfigService
  ) {
    this.http = http;
    this.baseUrl = appConfigService.apiBaseUrl;
  }

  /**
   * @param model (optional)
   * @return Success
   */
  authenticate(model: AuthenticateModel | null | undefined): Observable<AuthenticateResultModel> {
    let url_ = this.baseUrl + "/api/TokenAuth/Authenticate";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(model);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processAuthenticate(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processAuthenticate(<any>response_);
        } catch (e) {
          return <Observable<AuthenticateResultModel>><any>_observableThrow(e);
        }
      } else
        return <Observable<AuthenticateResultModel>><any>_observableThrow(response_);
    }));
  }

  protected processAuthenticate(response: HttpResponseBase): Observable<AuthenticateResultModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? AuthenticateResultModel.fromJS(resultData200) : new AuthenticateResultModel();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<AuthenticateResultModel>(<any>null);
  }

  /**
   * @return Success
   */
  getExternalAuthenticationProviders(): Observable<ExternalLoginProviderInfoModel[]> {
    let url_ = this.baseUrl + "/api/TokenAuth/GetExternalAuthenticationProviders";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processGetExternalAuthenticationProviders(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetExternalAuthenticationProviders(<any>response_);
        } catch (e) {
          return <Observable<ExternalLoginProviderInfoModel[]>><any>_observableThrow(e);
        }
      } else
        return <Observable<ExternalLoginProviderInfoModel[]>><any>_observableThrow(response_);
    }));
  }

  protected processGetExternalAuthenticationProviders(response: HttpResponseBase): Observable<ExternalLoginProviderInfoModel[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (resultData200 && resultData200.constructor === Array) {
          result200 = [];
          for (let item of resultData200)
            result200.push(ExternalLoginProviderInfoModel.fromJS(item));
        }
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<ExternalLoginProviderInfoModel[]>(<any>null);
  }

  /**
   * @param model (optional)
   * @return Success
   */
  externalAuthenticate(model: ExternalAuthenticateModel | null | undefined): Observable<ExternalAuthenticateResultModel> {
    let url_ = this.baseUrl + "/api/TokenAuth/ExternalAuthenticate";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(model);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processExternalAuthenticate(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processExternalAuthenticate(<any>response_);
        } catch (e) {
          return <Observable<ExternalAuthenticateResultModel>><any>_observableThrow(e);
        }
      } else
        return <Observable<ExternalAuthenticateResultModel>><any>_observableThrow(response_);
    }));
  }

  protected processExternalAuthenticate(response: HttpResponseBase): Observable<ExternalAuthenticateResultModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? ExternalAuthenticateResultModel.fromJS(resultData200) : new ExternalAuthenticateResultModel();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<ExternalAuthenticateResultModel>(<any>null);
  }
}

@Injectable()
export class AccountServiceProxy {
  baseUrl: string;
  http: HttpClient;
  jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;
  userCompanyRegistered: boolean;
  userCompanyImg: string;
  userProfileImg: string;
  constructor(@Inject(HttpClient) http: HttpClient,
    private appConfigService: AppConfigService
  ) {
    this.http = http;
    this.baseUrl = appConfigService.apiBaseUrl;
  }



  register(input: RegisterInput | null | undefined): Observable<RegisterOutput> {
    let url_ = this.baseUrl + '/api/services/app/Account/Register';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(input);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      })
    };

    return this.http.request('post', url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processRegister(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processRegister(<any>response_);
        } catch (e) {
          return <Observable<RegisterOutput>><any>_observableThrow(e);
        }
      } else {
        return <Observable<RegisterOutput>><any>_observableThrow(response_);
      }
    }));
  }

  processRegister(response: HttpResponseBase): Observable<RegisterOutput> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? RegisterOutput.fromJS(resultData200) : new RegisterOutput();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      }));
    }
    return _observableOf<RegisterOutput>(<any>null);
  }

  createUserProfile(input: UserProfileInputDto | null | undefined): Observable<UserProfileOutputDto> {
    let url_ = this.baseUrl + '/api/services/app/UserProfile/Create';
    url_ = url_.replace(/[?&]$/, '');
    const content_ = JSON.stringify(input);
    const options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      })
    };

    return this.http.request('post', url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processCreateUserProfile(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCreateUserProfile(<any>response_);
        } catch (e) {
          return <Observable<UserProfileOutputDto>><any>_observableThrow(e);
        }
      } else {
        return <Observable<UserProfileOutputDto>><any>_observableThrow(response_);
      }
    }));
  }

  /**
  * @param input  ContactUsDto
  * @return Success
  */
  contactUs(input: ContactUsDto | null | undefined): Observable<boolean> {
    let url_ = this.baseUrl + "/api/services/app/Account/ContactUs";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(input);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processContactUs(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processContactUs(<any>response_);
        } catch (e) {
          return <Observable<boolean>><any>_observableThrow(e);
        }
      } else
        return <Observable<boolean>><any>_observableThrow(response_);
    }));
  }

  protected processContactUs(response: HttpResponseBase): Observable<boolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 !== undefined ? resultData200 : <any>null;
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<boolean>(<any>null);
  }

  /**
  * @param input  ForgotPasswordDto
  * @return Success
  */
  changeUserPassword(input: ForgotPasswordDto | null | undefined): Observable<boolean> {
    let url_ = this.baseUrl + "/api/services/app/Account/ChangePassword";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(input);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processChangeUserPassword(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processChangeUserPassword(<any>response_);
        } catch (e) {
          return <Observable<boolean>><any>_observableThrow(e);
        }
      } else
        return <Observable<boolean>><any>_observableThrow(response_);
    }));
  }

  protected processChangeUserPassword(response: HttpResponseBase): Observable<boolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 !== undefined ? resultData200 : <any>null;
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<boolean>(<any>null);
  }

  /**
  * @param input  string
  * @return Success
  */
  markJobAsComplete(input: JobAdDto | null | undefined): Observable<boolean> {
    let url_ = this.baseUrl + "/api/services/app/JobAd/MarkJobAsComplete";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(input);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processMarkJobAsComplete(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processMarkJobAsComplete(<any>response_);
        } catch (e) {
          return <Observable<boolean>><any>_observableThrow(e);
        }
      } else
        return <Observable<boolean>><any>_observableThrow(response_);
    }));
  }

  protected processMarkJobAsComplete(response: HttpResponseBase): Observable<boolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 !== undefined ? resultData200 : <any>null;
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<boolean>(<any>null);
  }

  /**
  * @return Success
  */
  getCheckForPresentExperience(): Observable<boolean> {
    let url_ = this.baseUrl + "/api/services/app/UserExperience/CheckForPresentExperience";
    url_ = url_.replace(/[?&]$/, "");

    //const content_ = JSON.stringify(input);

    let options_: any = {
      //body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processGetCheckForPresentExperience(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetCheckForPresentExperience(<any>response_);
        } catch (e) {
          return <Observable<boolean>><any>_observableThrow(e);
        }
      } else
        return <Observable<boolean>><any>_observableThrow(response_);
    }));
  }

  protected processGetCheckForPresentExperience(response: HttpResponseBase): Observable<boolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 !== undefined ? resultData200 : <any>null;
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<boolean>(<any>null);
  }


  /**
  * @param input  string
  * @return Success
  */
  resendVerificationEmail(input: ResendVerificationEmailInputDto | null | undefined): Observable<boolean> {
    let url_ = this.baseUrl + "/api/services/app/Account/ResendVerificationEmail";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(input);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processResendVerificationEmail(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processResendVerificationEmail(<any>response_);
        } catch (e) {
          return <Observable<boolean>><any>_observableThrow(e);
        }
      } else
        return <Observable<boolean>><any>_observableThrow(response_);
    }));
  }

  protected processResendVerificationEmail(response: HttpResponseBase): Observable<boolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 !== undefined ? resultData200 : <any>null;
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<boolean>(<any>null);
  }

  /**
  * @param input  ForgotPasswordInputDto
  * @return Success
  */
  sendResetPasswordEmail(input: ForgotPasswordInputDto | null | undefined): Observable<boolean> {
    let url_ = this.baseUrl + "/api/services/app/Account/SendResetPasswordEmail";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(input);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processSendResetPasswordEmail(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processSendResetPasswordEmail(<any>response_);
        } catch (e) {
          return <Observable<boolean>><any>_observableThrow(e);
        }
      } else
        return <Observable<boolean>><any>_observableThrow(response_);
    }));
  }

  protected processSendResetPasswordEmail(response: HttpResponseBase): Observable<boolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 !== undefined ? resultData200 : <any>null;
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<boolean>(<any>null);
  }


  /**
  * @param input  ContactConfirmInputDto
  * @return Success
  */
  contactConfirmation(input: ContactConfirmInputDto | null | undefined): Observable<boolean> {
    let url_ = this.baseUrl + '/api/services/app/UserProfile/ContactConfirmation';
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(input);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processContactConfirmation(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processContactConfirmation(<any>response_);
        } catch (e) {
          return <Observable<boolean>><any>_observableThrow(e);
        }
      } else
        return <Observable<boolean>><any>_observableThrow(response_);
    }));
  }

  protected processContactConfirmation(response: HttpResponseBase): Observable<boolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 !== undefined ? resultData200 : <any>null;
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<boolean>(<any>null);
  }


  sendUserMobileOPT(): Observable<UserProfileOutputDto> {
    let url_ = this.baseUrl + '/api/services/app/UserProfile/SendSMSConfirmationCode';
    url_ = url_.replace(/[?&]$/, '');
    const content_ = JSON.stringify("");
    const options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      })
    };

    return this.http.request('post', url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processsendUserMobileOPT(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processsendUserMobileOPT(<any>response_);
        } catch (e) {
          return <Observable<UserProfileOutputDto>><any>_observableThrow(e);
        }
      } else {
        return <Observable<UserProfileOutputDto>><any>_observableThrow(response_);
      }
    }));
  }

  processsendUserMobileOPT(response: HttpResponseBase): Observable<UserProfileOutputDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    const _headers: any = {};
    if (response.headers) {
      for (const key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        const resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? UserProfileOutputDto.fromJS(resultData200) : new UserProfileOutputDto();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      }));
    }
    return _observableOf<UserProfileOutputDto>(<any>null);
  }

  getUserBehaviourResult(userId: number): Observable<UserTestResultDto> {
    let url_ = this.baseUrl + '/api/services/app/UserTest/GetBehaviourTestResult?id=' + userId;
    url_ = url_.replace(/[?&]$/, '');
    //const content_ = JSON.stringify(input);
    const options_: any = {
      //body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      })
    };

    return this.http.request('get', url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processUserBehaviourResult(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processUserBehaviourResult(<any>response_);
        } catch (e) {
          return <Observable<UserTestResultDto>><any>_observableThrow(e);
        }
      } else {
        return <Observable<UserTestResultDto>><any>_observableThrow(response_);
      }
    }));
  }

  processUserBehaviourResult(response: HttpResponseBase): Observable<UserTestResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    const _headers: any = {};
    if (response.headers) {
      for (const key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        const resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? UserTestResultDto.fromJS(resultData200) : new UserTestResultDto();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      }));
    }
    return _observableOf<UserTestResultDto>(<any>null);
  }

  getUserPreference(): Observable<UserPreferenceDto> {
    let url_ = this.baseUrl + '/api/services/app/UserPreference/GetByUserId';
    url_ = url_.replace(/[?&]$/, '');
    // const content_ = JSON.stringify(input);
    const options_: any = {
      //body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      })
    };

    return this.http.request('get', url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processGetUserPreference(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetUserPreference(<any>response_);
        } catch (e) {
          return <Observable<UserPreferenceDto>><any>_observableThrow(e);
        }
      } else {
        return <Observable<UserPreferenceDto>><any>_observableThrow(response_);
      }
    }));
  }

  processGetUserPreference(response: HttpResponseBase): Observable<UserPreferenceDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    const _headers: any = {};
    if (response.headers) {
      for (const key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        const resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? UserPreferenceDto.fromJS(resultData200) : new UserPreferenceDto();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      }));
    }
    return _observableOf<UserPreferenceDto>(<any>null);
  }

  getUserInfo(): Observable<UserInfoDto> {
    let url_ = this.baseUrl + '/api/services/app/UserProfile/GetUserInfo';
    url_ = url_.replace(/[?&]$/, '');
    //const content_ = JSON.stringify(input);
    const options_: any = {
      // body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      })
    };

    return this.http.request('get', url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processGetUserInfo(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetUserInfo(<any>response_);
        } catch (e) {
          return <Observable<UserInfoDto>><any>_observableThrow(e);
        }
      } else {
        return <Observable<UserInfoDto>><any>_observableThrow(response_);
      }
    }));
  }

  processGetUserInfo(response: HttpResponseBase): Observable<UserInfoDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    const _headers: any = {};
    if (response.headers) {
      for (const key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        const resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? UserInfoDto.fromJS(resultData200) : new UserInfoDto();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      }));
    }
    return _observableOf<UserInfoDto>(<any>null);
  }

  getUserProfile(input: number | null | undefined): Observable<UserProfileOutputDto> {
    let url_ = this.baseUrl + '/api/services/app/UserProfile/GetByUserId?id=' + input;
    url_ = url_.replace(/[?&]$/, '');
    const content_ = JSON.stringify(input);
    const options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      })
    };

    return this.http.request('get', url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processCreateUserProfile(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCreateUserProfile(<any>response_);
        } catch (e) {
          return <Observable<UserProfileOutputDto>><any>_observableThrow(e);
        }
      } else {
        return <Observable<UserProfileOutputDto>><any>_observableThrow(response_);
      }
    }));
  }

  processCreateUserProfile(response: HttpResponseBase): Observable<UserProfileOutputDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    const _headers: any = {};
    if (response.headers) {
      for (const key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        const resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? UserProfileOutputDto.fromJS(resultData200) : new UserProfileOutputDto();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      }));
    }
    return _observableOf<UserProfileOutputDto>(<any>null);
  }

  updateUserFavouriteQuote(input: UserProfileInputDto | null | undefined): Observable<UserProfileOutputDto> {
    let url_ = this.baseUrl + '/api/services/app/UserProfile/AddUpdateFavouriteQuote';
    url_ = url_.replace(/[?&]$/, '');
    const content_ = JSON.stringify(input);
    const options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      })
    };

    return this.http.request('post', url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processCreateUserProfile(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCreateUserProfile(<any>response_);
        } catch (e) {
          return <Observable<UserProfileOutputDto>><any>_observableThrow(e);
        }
      } else {
        return <Observable<UserProfileOutputDto>><any>_observableThrow(response_);
      }
    }));
  }

  isTenantAvailable(input: IsTenantAvailableInput | null | undefined): Observable<IsTenantAvailableOutput> {
    let url_ = this.baseUrl + '/api/services/app/Account/IsTenantAvailable';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(input);

    const options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      })
    };

    return this.http.request('post', url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processIsTenantAvailable(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processIsTenantAvailable(<any>response_);
        } catch (e) {
          return <Observable<IsTenantAvailableOutput>><any>_observableThrow(e);
        }
      } else {
        return <Observable<IsTenantAvailableOutput>><any>_observableThrow(response_);
      }
    }));
  }

  processIsTenantAvailable(response: HttpResponseBase): Observable<IsTenantAvailableOutput> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? IsTenantAvailableOutput.fromJS(resultData200) : new IsTenantAvailableOutput();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      }));
    }
    return _observableOf<IsTenantAvailableOutput>(<any>null);
  }

  saveInvitedExistingUser(input: ConfirmInvitationDto | null | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/services/app/Company/SaveInvitedExistingUser';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(input);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      })
    };

    return this.http.request('post', url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processSaveInvitedExistingUser(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processSaveInvitedExistingUser(<any>response_);
        } catch (e) {
          return <Observable<void>><any>_observableThrow(e);
        }
      } else {
        return <Observable<void>><any>_observableThrow(response_);
      }
    }));
  }

  processSaveInvitedExistingUser(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
        // result200 = resultData200 ? void.fromJS(resultData200) : new void();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(<any>null);
  }

  verifyEmail(userId: number, code: string): Observable<ConfirmEmailOuputDto> {
    let url_ = this.baseUrl + `/api/services/app/Account/GetConfirmEmail?userId=${userId}&code=${code}`;
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      body: { userId: userId, code: code },
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      })
    };

    return this.http.request('get', url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processConfirmEmail(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processConfirmEmail(<any>response_);
        } catch (e) {
          return <Observable<ConfirmEmailOuputDto>><any>_observableThrow(e);
        }
      } else {
        return <Observable<ConfirmEmailOuputDto>><any>_observableThrow(response_);
      }
    }));
  }

  processConfirmEmail(response: HttpResponseBase): Observable<ConfirmEmailOuputDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {};
    if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? ConfirmEmailOuputDto.fromJS(resultData200) : new ConfirmEmailOuputDto();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      }));
    }
    return _observableOf<ConfirmEmailOuputDto>(<any>null);
  }

  getUserEducations(userId: number): Observable<ListResultDtoOfUserEducationDto> {
    let url_ = this.baseUrl + '/api/services/app/UserEducation/GetAll?id=' + userId;
    url_ = url_.replace(/[?&]$/, '');

    const options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      })
    };

    return this.http.request('get', url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processGetUserEducations(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetUserEducations(<any>response_);
        } catch (e) {
          return <Observable<ListResultDtoOfUserEducationDto>><any>_observableThrow(e);
        }
      } else {
        return <Observable<ListResultDtoOfUserEducationDto>><any>_observableThrow(response_);
      }
    }));
  }

  private processGetUserEducations(response: HttpResponseBase): Observable<ListResultDtoOfUserEducationDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    const _headers: any = {};
    if (response.headers) {
      for (const key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        const resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? ListResultDtoOfUserEducationDto.fromJS(resultData200) : new ListResultDtoOfUserEducationDto();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      }));
    }
    return _observableOf<ListResultDtoOfUserEducationDto>(<any>null);
  }

  /**
  * @param id (optional)
  * @return Success
  */
  delete(id: number | null | undefined, deleteUrl: string | null | undefined): Observable<void> {
    let url_ = this.baseUrl + deleteUrl;
    if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
      })
    };

    return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processDelete(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processDelete(<any>response_);
        } catch (e) {
          return <Observable<void>><any>_observableThrow(e);
        }
      } else
        return <Observable<void>><any>_observableThrow(response_);
    }));
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return _observableOf<void>(<any>null);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(<any>null);
  }

  createUserEducation(input: UserEducationDto | null | undefined): Observable<UserEducationDto> {
    let url_ = this.baseUrl + '/api/services/app/UserEducation/Create';
    url_ = url_.replace(/[?&]$/, '');
    const content_ = JSON.stringify(input);
    const options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      })
    };

    return this.http.request('post', url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processCreateUserEducation(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCreateUserEducation(<any>response_);
        } catch (e) {
          return <Observable<UserEducationDto>><any>_observableThrow(e);
        }
      } else {
        return <Observable<UserEducationDto>><any>_observableThrow(response_);
      }
    }));
  }

  processCreateUserEducation(response: HttpResponseBase): Observable<UserEducationDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    const _headers: any = {};
    if (response.headers) {
      for (const key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        const resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? UserEducationDto.fromJS(resultData200) : new UserEducationDto();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      }));
    }
    return _observableOf<UserEducationDto>(<any>null);
  }

  getUserPorfolios(userId: number): Observable<ListResultDtoOfUserImageDto> {
    let url_ = this.baseUrl + '/api/services/app/UserProfile/GetAllUserPorfolios?id=' + userId;
    url_ = url_.replace(/[?&]$/, '');

    const options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      })
    };

    return this.http.request('get', url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processgetUserPorfolios(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processgetUserPorfolios(<any>response_);
        } catch (e) {
          return <Observable<ListResultDtoOfUserImageDto>><any>_observableThrow(e);
        }
      } else {
        return <Observable<ListResultDtoOfUserImageDto>><any>_observableThrow(response_);
      }
    }));
  }

  private processgetUserPorfolios(response: HttpResponseBase): Observable<ListResultDtoOfUserImageDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    const _headers: any = {};
    if (response.headers) {
      for (const key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        const resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? ListResultDtoOfUserImageDto.fromJS(resultData200) : new ListResultDtoOfUserImageDto();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      }));
    }
    return _observableOf<ListResultDtoOfUserImageDto>(<any>null);
  }

  getUserCertifications(userId: number): Observable<ListResultDtoOfUserCertificationDto> {
    let url_ = this.baseUrl + '/api/services/app/UserCertificate/GetByUserId?id=' + userId;
    url_ = url_.replace(/[?&]$/, '');

    const options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      })
    };

    return this.http.request('get', url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processgetUserCertifications(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processgetUserCertifications(<any>response_);
        } catch (e) {
          return <Observable<ListResultDtoOfUserCertificationDto>><any>_observableThrow(e);
        }
      } else {
        return <Observable<ListResultDtoOfUserCertificationDto>><any>_observableThrow(response_);
      }
    }));
  }

  private processgetUserCertifications(response: HttpResponseBase): Observable<ListResultDtoOfUserCertificationDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    const _headers: any = {};
    if (response.headers) {
      for (const key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        const resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? ListResultDtoOfUserCertificationDto.fromJS(resultData200) : new ListResultDtoOfUserCertificationDto();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      }));
    }
    return _observableOf<ListResultDtoOfUserCertificationDto>(<any>null);
  }

  createUserCertification(input: UserCertificationDto | null | undefined): Observable<UserCertificationDto> {
    let url_ = this.baseUrl + '/api/services/app/UserCertificate/Create';
    url_ = url_.replace(/[?&]$/, '');
    const content_ = JSON.stringify(input);
    const options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      })
    };

    return this.http.request('post', url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processCreateUserCertification(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCreateUserCertification(<any>response_);
        } catch (e) {
          return <Observable<UserCertificationDto>><any>_observableThrow(e);
        }
      } else {
        return <Observable<UserCertificationDto>><any>_observableThrow(response_);
      }
    }));
  }

  processCreateUserCertification(response: HttpResponseBase): Observable<UserCertificationDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    const _headers: any = {};
    if (response.headers) {
      for (const key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        const resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? UserCertificationDto.fromJS(resultData200) : new UserCertificationDto();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      }));
    }
    return _observableOf<UserCertificationDto>(<any>null);
  }

  getUserCertificateById(userCertificateId: number): Observable<UserCertificationDto> {
    let url_ = this.baseUrl + '/api/services/app/UserCertificate/GetById?id=' + userCertificateId;
    url_ = url_.replace(/[?&]$/, '');

    const options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      })
    };

    return this.http.request('get', url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processgetUserCertificateById(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processgetUserCertificateById(<any>response_);
        } catch (e) {
          return <Observable<UserCertificationDto>><any>_observableThrow(e);
        }
      } else {
        return <Observable<UserCertificationDto>><any>_observableThrow(response_);
      }
    }));
  }

  private processgetUserCertificateById(response: HttpResponseBase): Observable<UserCertificationDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    const _headers: any = {};
    if (response.headers) {
      for (const key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        const resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? UserCertificationDto.fromJS(resultData200) : new UserCertificationDto();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      }));
    }
    return _observableOf<UserCertificationDto>(<any>null);
  }


  getUserEducationById(userEducationId: number): Observable<UserEducationDto> {
    let url_ = this.baseUrl + '/api/services/app/UserEducation/GetById?id=' + userEducationId;
    url_ = url_.replace(/[?&]$/, '');

    const options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      })
    };

    return this.http.request('get', url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processgetUserEducationById(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processgetUserEducationById(<any>response_);
        } catch (e) {
          return <Observable<UserEducationDto>><any>_observableThrow(e);
        }
      } else {
        return <Observable<UserEducationDto>><any>_observableThrow(response_);
      }
    }));
  }

  private processgetUserEducationById(response: HttpResponseBase): Observable<UserEducationDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    const _headers: any = {};
    if (response.headers) {
      for (const key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        const resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? UserEducationDto.fromJS(resultData200) : new UserEducationDto();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      }));
    }
    return _observableOf<UserEducationDto>(<any>null);
  }

  getUserExperienceById(userExperienceId: number): Observable<UserExperienceDto> {
    let url_ = this.baseUrl + '/api/services/app/UserExperience/GetById?id=' + userExperienceId;
    url_ = url_.replace(/[?&]$/, '');

    const options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      })
    };

    return this.http.request('get', url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processgetUserExperienceById(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processgetUserExperienceById(<any>response_);
        } catch (e) {
          return <Observable<UserExperienceDto>><any>_observableThrow(e);
        }
      } else {
        return <Observable<UserExperienceDto>><any>_observableThrow(response_);
      }
    }));
  }

  private processgetUserExperienceById(response: HttpResponseBase): Observable<UserExperienceDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    const _headers: any = {};
    if (response.headers) {
      for (const key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        const resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? UserExperienceDto.fromJS(resultData200) : new UserExperienceDto();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      }));
    }
    return _observableOf<UserExperienceDto>(<any>null);
  }

  getUserExperiences(userId: number): Observable<ListResultDtoOfUserExperienceDto> {
    let url_ = this.baseUrl + '/api/services/app/UserExperience/GetByUserId?id=' + userId;
    url_ = url_.replace(/[?&]$/, '');

    const options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      })
    };

    return this.http.request('get', url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processgetUserExperiences(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processgetUserExperiences(<any>response_);
        } catch (e) {
          return <Observable<ListResultDtoOfUserExperienceDto>><any>_observableThrow(e);
        }
      } else {
        return <Observable<ListResultDtoOfUserExperienceDto>><any>_observableThrow(response_);
      }
    }));
  }

  private processgetUserExperiences(response: HttpResponseBase): Observable<ListResultDtoOfUserExperienceDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    const _headers: any = {};
    if (response.headers) {
      for (const key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        const resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? ListResultDtoOfUserExperienceDto.fromJS(resultData200) : new ListResultDtoOfUserExperienceDto();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      }));
    }
    return _observableOf<ListResultDtoOfUserExperienceDto>(<any>null);
  }

  createUserExperience(input: UserExperienceDto | null | undefined): Observable<UserExperienceDto> {
    if (input.salary == null || input.salary == undefined) {
      input.salary = "0";
    }
    if (input.pastRoles.length > 0) {
      input.pastRoles.forEach(function (pastRole) {
        if (pastRole.salary == null || pastRole.salary == undefined) {
          pastRole.salary = 0;
        }
      });
    }
    let url_ = this.baseUrl + '/api/services/app/UserExperience/Create';
    url_ = url_.replace(/[?&]$/, '');
    const content_ = JSON.stringify(input);
    const options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      })
    };

    return this.http.request('post', url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processCreateUserExperience(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCreateUserExperience(<any>response_);
        } catch (e) {
          return <Observable<UserExperienceDto>><any>_observableThrow(e);
        }
      } else {
        return <Observable<UserExperienceDto>><any>_observableThrow(response_);
      }
    }));
  }

  processCreateUserExperience(response: HttpResponseBase): Observable<UserExperienceDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    const _headers: any = {};
    if (response.headers) {
      for (const key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        const resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? UserExperienceDto.fromJS(resultData200) : new UserExperienceDto();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      }));
    }
    return _observableOf<UserExperienceDto>(<any>null);
  }

  uploadUserCertificationAttachment(input: FormData | null | undefined): Observable<UserCertificationDto> {
    let url_ = this.baseUrl + '/api/Files/UploadUserUserCertificateAttacment';
    url_ = url_.replace(/[?&]$/, '');
    const content_ = input;
    const options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        //'Content-Type': 'application/json',
        //'Content-type': 'image/jpeg',
        'Accept': 'application/json'
      })
    };

    return this.http.request('post', url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processUserCertificationAttachment(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processUserCertificationAttachment(<any>response_);
        } catch (e) {
          return <Observable<UserCertificationDto>><any>_observableThrow(e);
        }
      } else {
        return <Observable<UserCertificationDto>><any>_observableThrow(response_);
      }
    }));
  }

  processUserCertificationAttachment(response: HttpResponseBase): Observable<UserCertificationDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    const _headers: any = {};
    if (response.headers) {
      for (const key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        const resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? UserCertificationDto.fromJS(resultData200) : new UserCertificationDto();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      }));
    }
    return _observableOf<UserCertificationDto>(<any>null);
  }

  uploadCompanyIncorpAttachment(input: FormData | null | undefined): Observable<TenantDto> {
    let url_ = this.baseUrl + '/api/Files/UploadCompanyIncorporationAttacment';
    url_ = url_.replace(/[?&]$/, '');
    const content_ = input;
    const options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        //'Content-Type': 'application/json',
        //'Content-type': 'image/jpeg',
        'Accept': 'application/json'
      })
    };

    return this.http.request('post', url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processCompanyIncorpttachment(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCompanyIncorpttachment(<any>response_);
        } catch (e) {
          return <Observable<TenantDto>><any>_observableThrow(e);
        }
      } else {
        return <Observable<TenantDto>><any>_observableThrow(response_);
      }
    }));
  }

  processCompanyIncorpttachment(response: HttpResponseBase): Observable<TenantDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    const _headers: any = {};
    if (response.headers) {
      for (const key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        const resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? TenantDto.fromJS(resultData200) : new TenantDto();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      }));
    }
    return _observableOf<TenantDto>(<any>null);
  }

  uploadCompanyCoverImageAttachment(input: FormData | null | undefined): Observable<CompanyImageDto> {
    let url_ = this.baseUrl + '/api/services/app/CompanyImage/AddUpdateCoverImage';
    url_ = url_.replace(/[?&]$/, '');
    const content_ = input;
    const options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Accept': 'application/json'
      })
    };

    return this.http.request('post', url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processUploadCompanyCoverImageAttachment(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processUploadCompanyCoverImageAttachment(<any>response_);
        } catch (e) {
          return <Observable<CompanyImageDto>><any>_observableThrow(e);
        }
      } else {
        return <Observable<CompanyImageDto>><any>_observableThrow(response_);
      }
    }));
  }

  processUploadCompanyCoverImageAttachment(response: HttpResponseBase): Observable<CompanyImageDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    const _headers: any = {};
    if (response.headers) {
      for (const key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        const resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? CompanyImageDto.fromJS(resultData200) : new CompanyImageDto();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      }));
    }
    return _observableOf<CompanyImageDto>(<any>null);
  }

  uploadCompanyProfileImageAttachment(input: FormData | null | undefined): Observable<CompanyImageDto> {
    let url_ = this.baseUrl + '/api/services/app/CompanyImage/AddUpdateProfileImage';
    url_ = url_.replace(/[?&]$/, '');
    const content_ = input;
    const options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Accept': 'application/json'
      })
    };

    return this.http.request('post', url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processUploadCompanyProfileImageAttachment(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processUploadCompanyProfileImageAttachment(<any>response_);
        } catch (e) {
          return <Observable<CompanyImageDto>><any>_observableThrow(e);
        }
      } else {
        return <Observable<CompanyImageDto>><any>_observableThrow(response_);
      }
    }));
  }

  processUploadCompanyProfileImageAttachment(response: HttpResponseBase): Observable<CompanyImageDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    const _headers: any = {};
    if (response.headers) {
      for (const key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        const resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? CompanyImageDto.fromJS(resultData200) : new CompanyImageDto();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      }));
    }
    return _observableOf<CompanyImageDto>(<any>null);
  }

  uploadUserProfileImageAttachment(input: FormData | null | undefined): Observable<UserProfileOutputDto> {
    let url_ = this.baseUrl + '/api/services/app/UserProfile/AddUpdateProfileImage';
    url_ = url_.replace(/[?&]$/, '');
    const content_ = input;
    const options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Accept': 'application/json'
      })
    };

    return this.http.request('post', url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processUserProfileImageAttachment(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processUserProfileImageAttachment(<any>response_);
        } catch (e) {
          return <Observable<UserProfileOutputDto>><any>_observableThrow(e);
        }
      } else {
        return <Observable<UserProfileOutputDto>><any>_observableThrow(response_);
      }
    }));
  }

  processUserProfileImageAttachment(response: HttpResponseBase): Observable<UserProfileOutputDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    const _headers: any = {};
    if (response.headers) {
      for (const key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        const resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? UserProfileOutputDto.fromJS(resultData200) : new UserProfileOutputDto();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      }));
    }
    return _observableOf<UserProfileOutputDto>(<any>null);
  }

  /**
  * @param input  FormData
  * @return Success
  */
  removeOfficeImage(input: number | null | undefined): Observable<boolean> {
    let url_ = this.baseUrl + "/api/services/app/CompanyImage/RemoveCompanyImage?id=" + input;
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(input);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        'Accept': 'application/json'
      })
    };

    return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processRemoveOfficeImage(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processRemoveOfficeImage(<any>response_);
        } catch (e) {
          return <Observable<boolean>><any>_observableThrow(e);
        }
      } else
        return <Observable<boolean>><any>_observableThrow(response_);
    }));
  }

  protected processRemoveOfficeImage(response: HttpResponseBase): Observable<boolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 !== undefined ? resultData200 : <any>null;
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<boolean>(<any>null);
  }

  /**
  * @param input  FormData
  * @return Success
  */
  removeCompanyDocument(input: number | null | undefined): Observable<boolean> {
    let url_ = this.baseUrl + "/api/services/app/CompanyImage/RemoveCompanyDocument?id=" + input;
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(input);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        'Accept': 'application/json'
      })
    };

    return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processRemoveCompanyDocument(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processRemoveCompanyDocument(<any>response_);
        } catch (e) {
          return <Observable<boolean>><any>_observableThrow(e);
        }
      } else
        return <Observable<boolean>><any>_observableThrow(response_);
    }));
  }

  protected processRemoveCompanyDocument(response: HttpResponseBase): Observable<boolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 !== undefined ? resultData200 : <any>null;
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<boolean>(<any>null);
  }

  /**
  * @param input  FormData
  * @return Success
  */
  removeUserPortfolio(input: number | null | undefined): Observable<boolean> {
    let url_ = this.baseUrl + "/api/services/app/UserProfile/DeletePortfolio?id=" + input;
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(input);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        'Accept': 'application/json'
      })
    };

    return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processRemoveUserPortfolio(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processRemoveUserPortfolio(<any>response_);
        } catch (e) {
          return <Observable<boolean>><any>_observableThrow(e);
        }
      } else
        return <Observable<boolean>><any>_observableThrow(response_);
    }));
  }

  protected processRemoveUserPortfolio(response: HttpResponseBase): Observable<boolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 !== undefined ? resultData200 : <any>null;
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<boolean>(<any>null);
  }

  uploadOfficeImageAttachment(input: FormData | null | undefined): Observable<CompanyImageDto> {
    let url_ = this.baseUrl + '/api/services/app/CompanyImage/AddCompanyImage';
    url_ = url_.replace(/[?&]$/, '');
    const content_ = input;
    const options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Accept': 'application/json'
      })
    };

    return this.http.request('post', url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processOfficeImageAttachment(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processOfficeImageAttachment(<any>response_);
        } catch (e) {
          return <Observable<CompanyImageDto>><any>_observableThrow(e);
        }
      } else {
        return <Observable<CompanyImageDto>><any>_observableThrow(response_);
      }
    }));
  }

  processOfficeImageAttachment(response: HttpResponseBase): Observable<CompanyImageDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    const _headers: any = {};
    if (response.headers) {
      for (const key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        const resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? CompanyImageDto.fromJS(resultData200) : new CompanyImageDto();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      }));
    }
    return _observableOf<CompanyImageDto>(<any>null);
  }

  uploadCompanyDocument(input: FormData | null | undefined): Observable<ListResultDtoOfCompanyImageDto> {
    let url_ = this.baseUrl + '/api/services/app/CompanyImage/AddCompanyDocument';
    url_ = url_.replace(/[?&]$/, '');
    const content_ = input;
    const options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Accept': 'application/json'
      })
    };

    return this.http.request('post', url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processCompanyDocument(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCompanyDocument(<any>response_);
        } catch (e) {
          return <Observable<ListResultDtoOfCompanyImageDto>><any>_observableThrow(e);
        }
      } else {
        return <Observable<ListResultDtoOfCompanyImageDto>><any>_observableThrow(response_);
      }
    }));
  }

  processCompanyDocument(response: HttpResponseBase): Observable<ListResultDtoOfCompanyImageDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    const _headers: any = {};
    if (response.headers) {
      for (const key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        const resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? ListResultDtoOfCompanyImageDto.fromJS(resultData200) : new ListResultDtoOfCompanyImageDto();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      }));
    }
    return _observableOf<ListResultDtoOfCompanyImageDto>(<any>null);
  }

  uploadUserPortfolioAttachment(input: FormData | null | undefined): Observable<ListResultDtoOfUserImageDto> {
    let url_ = this.baseUrl + '/api/services/app/UserProfile/AddPortfolio';
    url_ = url_.replace(/[?&]$/, '');
    const content_ = input;
    const options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Accept': 'application/json'
      })
    };

    return this.http.request('post', url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processUsePortfolioAttachment(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processUsePortfolioAttachment(<any>response_);
        } catch (e) {
          return <Observable<ListResultDtoOfUserImageDto>><any>_observableThrow(e);
        }
      } else {
        return <Observable<ListResultDtoOfUserImageDto>><any>_observableThrow(response_);
      }
    }));
  }

  processUsePortfolioAttachment(response: HttpResponseBase): Observable<ListResultDtoOfUserImageDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    const _headers: any = {};
    if (response.headers) {
      for (const key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        const resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? ListResultDtoOfUserImageDto.fromJS(resultData200) : new ListResultDtoOfUserImageDto();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      }));
    }
    return _observableOf<ListResultDtoOfUserImageDto>(<any>null);
  }

  uploadUserEducationAttachment(input: FormData | null | undefined): Observable<UserEducationDto> {
    let url_ = this.baseUrl + '/api/Files/UploadUserEducationAttacment';
    url_ = url_.replace(/[?&]$/, '');
    const content_ = input;
    const options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        //'Content-Type': 'application/json',
        //'Content-type': 'image/jpeg',
        'Accept': 'application/json'
      })
    };

    return this.http.request('post', url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processUserEducationAttachment(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processUserEducationAttachment(<any>response_);
        } catch (e) {
          return <Observable<UserEducationDto>><any>_observableThrow(e);
        }
      } else {
        return <Observable<UserEducationDto>><any>_observableThrow(response_);
      }
    }));
  }

  processUserEducationAttachment(response: HttpResponseBase): Observable<UserEducationDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    const _headers: any = {};
    if (response.headers) {
      for (const key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        const resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? UserEducationDto.fromJS(resultData200) : new UserEducationDto();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      }));
    }
    return _observableOf<UserEducationDto>(<any>null);
  }

  uploadCompanyLogo(input: FormData | null | undefined): Observable<CompanyImageDto> {
    let url_ = this.baseUrl + '/api/Files/UploadLogo';
    url_ = url_.replace(/[?&]$/, '');
    const content_ = input;
    const options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        //'Content-Type': 'application/json',
        //'Content-type': 'image/jpeg',
        'Accept': 'application/json'
      })
    };

    return this.http.request('post', url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processUploadCompanyLogo(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processUploadCompanyLogo(<any>response_);
        } catch (e) {
          return <Observable<CompanyImageDto>><any>_observableThrow(e);
        }
      } else {
        return <Observable<CompanyImageDto>><any>_observableThrow(response_);
      }
    }));
  }

  processUploadCompanyLogo(response: HttpResponseBase): Observable<CompanyImageDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    const _headers: any = {};
    if (response.headers) {
      for (const key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        const resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? CompanyImageDto.fromJS(resultData200) : new CompanyImageDto();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      }));
    }
    return _observableOf<CompanyImageDto>(<any>null);
  }

  getCompanyLogo(): Observable<CompanyImageDto> {
    let url_ = this.baseUrl + '/api/services/app/CompanyImage/GetCompanyLogo';
    url_ = url_.replace(/[?&]$/, '');

    const options_: any = {
      body: '',
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      })
    };

    return this.http.request('get', url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processGetCompanyLogo(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetCompanyLogo(<any>response_);
        } catch (e) {
          return <Observable<CompanyImageDto>><any>_observableThrow(e);
        }
      } else {
        return <Observable<CompanyImageDto>><any>_observableThrow(response_);
      }
    }));
  }

  processGetCompanyLogo(response: HttpResponseBase): Observable<CompanyImageDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    const _headers: any = {};
    if (response.headers) {
      for (const key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        const resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? CompanyImageDto.fromJS(resultData200) : new CompanyImageDto();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      }));
    }
    return _observableOf<CompanyImageDto>(<any>null);
  }

  getCompanyCover(): Observable<CompanyImageDto> {
    let url_ = this.baseUrl + '/api/services/app/CompanyImage/GetCompanyCover';
    url_ = url_.replace(/[?&]$/, '');

    const options_: any = {
      body: '',
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      })
    };

    return this.http.request('get', url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processGetCompanyCover(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetCompanyCover(<any>response_);
        } catch (e) {
          return <Observable<CompanyImageDto>><any>_observableThrow(e);
        }
      } else {
        return <Observable<CompanyImageDto>><any>_observableThrow(response_);
      }
    }));
  }

  processGetCompanyCover(response: HttpResponseBase): Observable<CompanyImageDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    const _headers: any = {};
    if (response.headers) {
      for (const key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        const resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? CompanyImageDto.fromJS(resultData200) : new CompanyImageDto();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      }));
    }
    return _observableOf<CompanyImageDto>(<any>null);
  }

  getCompanyDocuments(): Observable<ListResultDtoOfCompanyImageDto> {
    let url_ = this.baseUrl + '/api/services/app/CompanyImage/GetCompanyDocuments';
    url_ = url_.replace(/[?&]$/, '');

    const options_: any = {
      body: '',
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      })
    };

    return this.http.request('get', url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processGetCompanyDocuments(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetCompanyDocuments(<any>response_);
        } catch (e) {
          return <Observable<ListResultDtoOfCompanyImageDto>><any>_observableThrow(e);
        }
      } else {
        return <Observable<ListResultDtoOfCompanyImageDto>><any>_observableThrow(response_);
      }
    }));
  }

  processGetCompanyDocuments(response: HttpResponseBase): Observable<ListResultDtoOfCompanyImageDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    const _headers: any = {};
    if (response.headers) {
      for (const key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        const resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? ListResultDtoOfCompanyImageDto.fromJS(resultData200) : new ListResultDtoOfCompanyImageDto();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      }));
    }
    return _observableOf<ListResultDtoOfCompanyImageDto>(<any>null);
  }

  getCompanyOtherImages(): Observable<ListResultDtoOfCompanyImageDto> {
    let url_ = this.baseUrl + '/api/services/app/CompanyImage/GetAllOtherImages';
    url_ = url_.replace(/[?&]$/, '');

    const options_: any = {
      body: '',
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      })
    };

    return this.http.request('get', url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processGetCompanyOtherImages(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetCompanyOtherImages(<any>response_);
        } catch (e) {
          return <Observable<ListResultDtoOfCompanyImageDto>><any>_observableThrow(e);
        }
      } else {
        return <Observable<ListResultDtoOfCompanyImageDto>><any>_observableThrow(response_);
      }
    }));
  }

  processGetCompanyOtherImages(response: HttpResponseBase): Observable<ListResultDtoOfCompanyImageDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    const _headers: any = {};
    if (response.headers) {
      for (const key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        const resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? ListResultDtoOfCompanyImageDto.fromJS(resultData200) : new ListResultDtoOfCompanyImageDto();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      }));
    }
    return _observableOf<ListResultDtoOfCompanyImageDto>(<any>null);
  }

  uploadCompanyCover(input: FormData | null | undefined): Observable<CompanyImageDto> {
    let url_ = this.baseUrl + '/api/Files/UploadCover';
    url_ = url_.replace(/[?&]$/, '');
    const content_ = input;
    const options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Accept': 'application/json'
      })
    };

    return this.http.request('post', url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processUploadCompanyCover(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processUploadCompanyCover(<any>response_);
        } catch (e) {
          return <Observable<CompanyImageDto>><any>_observableThrow(e);
        }
      } else {
        return <Observable<CompanyImageDto>><any>_observableThrow(response_);
      }
    }));
  }

  processUploadCompanyCover(response: HttpResponseBase): Observable<CompanyImageDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    const _headers: any = {};
    if (response.headers) {
      for (const key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        const resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? CompanyImageDto.fromJS(resultData200) : new CompanyImageDto();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      }));
    }
    return _observableOf<CompanyImageDto>(<any>null);
  }

  uploadCompanyImage(input: FormData | null | undefined): Observable<ListResultDtoOfCompanyImageDto> {
    //let url_ = this.baseUrl + '/api/services/app/CompanyImage/UploadImage';
    let url_ = this.baseUrl + '/api/Files/UploadImages';

    url_ = url_.replace(/[?&]$/, '');
    const content_ = input;
    const options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Accept': 'application/json'
      })
    };

    return this.http.request('post', url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processUploadCompanyImage(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processUploadCompanyImage(<any>response_);
        } catch (e) {
          return <Observable<ListResultDtoOfCompanyImageDto>><any>_observableThrow(e);
        }
      } else {
        return <Observable<ListResultDtoOfCompanyImageDto>><any>_observableThrow(response_);
      }
    }));
  }

  processUploadCompanyImage(response: HttpResponseBase): Observable<ListResultDtoOfCompanyImageDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    const _headers: any = {};
    if (response.headers) {
      for (const key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        const resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? ListResultDtoOfCompanyImageDto.fromJS(resultData200) : new ListResultDtoOfCompanyImageDto();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      }));
    }
    return _observableOf<ListResultDtoOfCompanyImageDto>(<any>null);
  }

  getSkillTree(): Observable<ListSkillCategoryDto> {
    let url_ = this.baseUrl + '/api/services/app/Skill/GetAllSkillCategories';
    url_ = url_.replace(/[?&]$/, '');

    const options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      })
    };

    return this.http.request('get', url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processGetSkillTree(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetSkillTree(<any>response_);
        } catch (e) {
          return <Observable<ListSkillCategoryDto>><any>_observableThrow(e);
        }
      } else {
        return <Observable<ListSkillCategoryDto>><any>_observableThrow(response_);
      }
    }));
  }

  private processGetSkillTree(response: HttpResponseBase): Observable<ListSkillCategoryDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    const _headers: any = {};
    if (response.headers) {
      for (const key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        const resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? ListSkillCategoryDto.fromJS(resultData200) : new ListSkillCategoryDto();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      }));
    }
    return _observableOf<ListSkillCategoryDto>(<any>null);
  }

  getUserSkill(skillCategoryId: number, skillTypeId: number, skillId: number, userId: number): Observable<ListUserSkillDto> {
    let url_ = this.baseUrl + `/api/services/app/UserSkill/GetUserSkills?SkillCategoryId=${skillCategoryId}&SkillTypeId=${skillTypeId}&SkillId=${skillId}&userId=${userId}`;
    url_ = url_.replace(/[?&]$/, '');

    const options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      })
    };

    return this.http.request('get', url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processGetUserSkill(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetUserSkill(<any>response_);
        } catch (e) {
          return <Observable<ListUserSkillDto>><any>_observableThrow(e);
        }
      } else {
        return <Observable<ListUserSkillDto>><any>_observableThrow(response_);
      }
    }));
  }

  private processGetUserSkill(response: HttpResponseBase): Observable<ListUserSkillDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    const _headers: any = {};
    if (response.headers) {
      for (const key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        const resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? ListUserSkillDto.fromJS(resultData200) : new ListUserSkillDto();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      }));
    }
    return _observableOf<ListUserSkillDto>(<any>null);
  }

  createUserSkill(input: UserSkillDto | null | undefined): Observable<UserSkillDto> {
    let url_ = this.baseUrl + '/api/services/app/UserSkill/Create';
    url_ = url_.replace(/[?&]$/, '');
    const content_ = JSON.stringify(input);
    const options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      })
    };

    return this.http.request('post', url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processCreateUserSkill(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCreateUserSkill(<any>response_);
        } catch (e) {
          return <Observable<UserSkillDto>><any>_observableThrow(e);
        }
      } else {
        return <Observable<UserSkillDto>><any>_observableThrow(response_);
      }
    }));
  }

  processCreateUserSkill(response: HttpResponseBase): Observable<UserSkillDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    const _headers: any = {};
    if (response.headers) {
      for (const key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        const resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? UserSkillDto.fromJS(resultData200) : new UserSkillDto();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      }));
    }
    return _observableOf<UserSkillDto>(<any>null);
  }

  createUserPreference(input: UserPreferenceDto | null | undefined): Observable<UserPreferenceDto> {
    let url_ = this.baseUrl + '/api/services/app/UserPreference/Create';
    url_ = url_.replace(/[?&]$/, '');
    const content_ = JSON.stringify(input);
    const options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      })
    };

    return this.http.request('post', url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processCreateUserPreference(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCreateUserPreference(<any>response_);
        } catch (e) {
          return <Observable<UserPreferenceDto>><any>_observableThrow(e);
        }
      } else {
        return <Observable<UserPreferenceDto>><any>_observableThrow(response_);
      }
    }));
  }

  processCreateUserPreference(response: HttpResponseBase): Observable<UserPreferenceDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    const _headers: any = {};
    if (response.headers) {
      for (const key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        const resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? UserPreferenceDto.fromJS(resultData200) : new UserPreferenceDto();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      }));
    }
    return _observableOf<UserPreferenceDto>(<any>null);
  }

  createCompany(input: TenantDto | null | undefined): Observable<TenantDto> {
    let url_ = this.baseUrl + '/api/services/app/Company/Create';
    url_ = url_.replace(/[?&]$/, '');
    const content_ = JSON.stringify(input);
    const options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      })
    };

    return this.http.request('post', url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processCreateCompany(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCreateCompany(<any>response_);
        } catch (e) {
          return <Observable<TenantDto>><any>_observableThrow(e);
        }
      } else {
        return <Observable<TenantDto>><any>_observableThrow(response_);
      }
    }));
  }

  processCreateCompany(response: HttpResponseBase): Observable<TenantDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    const _headers: any = {};
    if (response.headers) {
      for (const key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        const resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? TenantDto.fromJS(resultData200) : new TenantDto();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      }));
    }
    return _observableOf<TenantDto>(<any>null);
  }

  getCompany(): Observable<TenantDto> {
    let url_ = this.baseUrl + '/api/services/app/Company/GetUserCompany';
    url_ = url_.replace(/[?&]$/, '');
    const options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      })
    };

    return this.http.request('get', url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processGetCompany(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetCompany(<any>response_);
        } catch (e) {
          return <Observable<TenantDto>><any>_observableThrow(e);
        }
      } else {
        return <Observable<TenantDto>><any>_observableThrow(response_);
      }
    }));
  }

  processGetCompany(response: HttpResponseBase): Observable<TenantDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    const _headers: any = {};
    if (response.headers) {
      for (const key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        const resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? TenantDto.fromJS(resultData200) : new TenantDto();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      }));
    }
    return _observableOf<TenantDto>(<any>null);
  }

  getCompanyOverview(registrationNo: string): Observable<CompanyOverviewDto> {
    let url_ = this.baseUrl + '/api/services/app/Company/GetCompanyOverview?registrationNo=' + registrationNo;
    url_ = url_.replace(/[?&]$/, '');
    const options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      })
    };

    return this.http.request('get', url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processGetCompanyOverview(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetCompanyOverview(<any>response_);
        } catch (e) {
          return <Observable<CompanyOverviewDto>><any>_observableThrow(e);
        }
      } else {
        return <Observable<CompanyOverviewDto>><any>_observableThrow(response_);
      }
    }));
  }

  processGetCompanyOverview(response: HttpResponseBase): Observable<CompanyOverviewDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    const _headers: any = {};
    if (response.headers) {
      for (const key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        const resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? CompanyOverviewDto.fromJS(resultData200) : new CompanyOverviewDto();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      }));
    }
    return _observableOf<CompanyOverviewDto>(<any>null);
  }

  getCompanyById(tenantId: number): Observable<TenantDto> {
    let url_ = this.baseUrl + '/api/services/app/Company/GetCompanyById?tenantId=' + tenantId;
    url_ = url_.replace(/[?&]$/, '');
    const options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      })
    };

    return this.http.request('get', url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processGetCompanyById(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetCompanyById(<any>response_);
        } catch (e) {
          return <Observable<TenantDto>><any>_observableThrow(e);
        }
      } else {
        return <Observable<TenantDto>><any>_observableThrow(response_);
      }
    }));
  }

  processGetCompanyById(response: HttpResponseBase): Observable<TenantDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    const _headers: any = {};
    if (response.headers) {
      for (const key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        const resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? TenantDto.fromJS(resultData200) : new TenantDto();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      }));
    }
    return _observableOf<TenantDto>(<any>null);
  }

  saveCompanyInfo(input: TenantDto | null | undefined): Observable<TenantDto> {
    let url_ = this.baseUrl + '/api/services/app/Company/SaveCompanyInfo';
    url_ = url_.replace(/[?&]$/, '');
    const content_ = JSON.stringify(input);
    const options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      })
    };

    return this.http.request('post', url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processSaveCompanyInfo(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processSaveCompanyInfo(<any>response_);
        } catch (e) {
          return <Observable<TenantDto>><any>_observableThrow(e);
        }
      } else {
        return <Observable<TenantDto>><any>_observableThrow(response_);
      }
    }));
  }

  processSaveCompanyInfo(response: HttpResponseBase): Observable<TenantDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    const _headers: any = {};
    if (response.headers) {
      for (const key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        const resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? TenantDto.fromJS(resultData200) : new TenantDto();
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      }));
    }
    return _observableOf<TenantDto>(<any>null);
  }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
  if (result !== null && result !== undefined)
    return _observableThrow(result);
  else
    return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
  return new Observable<string>((observer: any) => {
    if (!blob) {
      observer.next("");
      observer.complete();
    } else {
      let reader = new FileReader();
      reader.onload = event => {
        observer.next((<any>event.target).result);
        observer.complete();
      };
      reader.readAsText(blob);
    }
  });
}
